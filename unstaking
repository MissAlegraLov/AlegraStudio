// ... [Importaciones y definiciones previas]

contract AlegraStudio is AccessControl, Pausable {
    // ... [Definiciones previas]

    struct ProjectProposal {
        address proposer;
        string projectName;
        string description;
        uint256 voteCount;
        bool approved;
    }

    mapping(address => uint256) public lastStakedTime; // Tiempo en que el usuario realizó el staking
    ProjectProposal[] public proposals;
    mapping(address => mapping(uint256 => bool)) public hasVoted; // Rastrea si un usuario ha votado en una propuesta

    uint256 public constant STAKING_PERIOD = 30 days; // Período mínimo para hacer unstaking
    uint256 public constant APPROVAL_THRESHOLD = 100; // Número de votos necesarios para aprobar una propuesta

    event ProjectProposed(address indexed proposer, uint256 proposalId);
    event Voted(address indexed voter, uint256 proposalId, bool support);
    event ProposalApproved(uint256 proposalId);

    // ... [Funciones previas]

    function unstakeTokens() external whenNotPaused {
        require(block.timestamp >= lastStakedTime[msg.sender].add(STAKING_PERIOD), "You need to wait the minimum staking period");
        uint256 amount = stakedAmount[msg.sender];
        require(rewardToken.transfer(msg.sender, amount), "Unstaking failed");
        stakedAmount[msg.sender] = 0;
        lastStakedTime[msg.sender] = 0;
        emit Unstaked(msg.sender, amount);
    }

    function proposeProject(string memory _name, string memory _description) external whenNotPaused {
        ProjectProposal memory newProposal;
        newProposal.proposer = msg.sender;
        newProposal.projectName = _name;
        newProposal.description = _description;
        newProposal.voteCount = 0;
        newProposal.approved = false;
        proposals.push(newProposal);
        emit ProjectProposed(msg.sender, proposals.length - 1);
    }

    function voteOnProposal(uint256 _proposalId, bool _support) external whenNotPaused {
        require(!hasVoted[msg.sender][_proposalId], "You've already voted on this proposal");
        if (_support) {
            proposals[_proposalId].voteCount = proposals[_proposalId].voteCount.add(1);
        } else {
            proposals[_proposalId].voteCount = proposals[_proposalId].voteCount.sub(1);
        }
        hasVoted[msg.sender][_proposalId] = true;
        emit Voted(msg.sender, _proposalId, _support);
    }

    function checkProposalApproval(uint256 _proposalId) external whenNotPaused returns(bool) {
        if (proposals[_proposalId].voteCount >= APPROVAL_THRESHOLD && !proposals[_proposalId].approved) {
            proposals[_proposalId].approved = true;
            emit ProposalApproved(_proposalId);
            return true;
        }
        return false;
    }
}
